# Windows Malware

## Call Stack spoofing

Some resources related to call stack spoofing:
- [x64 exception handling](https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64)
- 2022/06/30: [Spoofing Call Stacks To Confuse EDRs](https://labs.withsecure.com/publications/spoofing-call-stacks-to-confuse-edrs) by William Burgess
- [VulcanRaven](https://github.com/WithSecureLabs/CallStackSpoofer)
- 2022/12/08: [SilentMoonwalk: Implementing a dynamic Call Stack Spoofer](https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/) by Arash Parsa, aka waldo-irc, Athanasios Tserpelis, aka trickster0, and Alessandro Magnosi, aka klezVirus
- [Unwinder (tool)](https://github.com/Kudaes/Unwinder) by Kudaes

## Injection

- 2015/01/30 [An Improved Reflective DLL Injection Technique](https://disman.tl/2015/01/30/an-improved-reflective-dll-injection-technique.html) by Dan Staples
- [EPI (tool)](https://github.com/Kudaes/EPI) by Kudaes
- 2023/12/06 [The Pool Party You Will Never Forget: New Process Injection
  Techniques Using Windows Thread Pools](https://www.safebreach.com/blog/process-injection-using-windows-thread-pools) by Alon Leviev


## Heap encryption

- 2021/09/08 [Hook Heaps and Live Free](https://www.arashparsa.com/hook-heaps-and-live-free/) by Arash Parsa

## PE Loader

Being able to load PE binaries is an important feature that many malware
implement.

- [ReactOS Ntdll loader implementation](https://github.com/reactos/reactos/tree/master/dll/ntdll/ldr)
- [ReflectiveDllInjection (tool)](https://github.com/stephenfewer/ReflectiveDLLInjection) by Stephen Fewer
- [MemoryModule](https://github.com/fancycode/MemoryModule) by fancycode
- [DarkLoadLibrary (tool)](https://github.com/bats3c/DarkLoadLibrary) by bats3c
- [No-Consolation (tool)](https://github.com/fortra/No-Consolation) by S4ntiagoP
- [Donut (tool)](https://github.com/TheWover/donut) by odzhan and TheWover
- 2019/05/09  [Donut - Injecting .NET Assemblies as Shellcode](https://thewover.github.io/Introducing-Donut/) by The Wover
- [sRDI (tool)](https://github.com/monoxgas/sRDI) by monoxgas


### API sets

API sets are like subsets of libraries functionalities that can be bundled
together and will allow to be provided by different DLLs in different Windows
devices, like computers, Xbox, etc. A PE can import functions from
an API set and then the linker in runtime will redirect this import to the
proper library.

An example of apiset is like this one:

`api-ms-win-core-synch-l1-1-0.dll` -> `kernelbase.dll`

- [ApiSet](https://github.com/ajkhoury/ApiSet) by ajkhoury
- 2012/04/06 [Runtime DLL name resolution: ApiSetSchema - Part I](https://blog.quarkslab.com/runtime-dll-name-resolution-apisetschema-part-i.html) by Sébastien Renaud
- 2012/04/25 [Runtime DLL name resolution: ApiSetSchema - Part II](https://blog.quarkslab.com/runtime-dll-name-resolution-apisetschema-part-ii.html) by Sébastien Renaud
- [The API Set Schema](https://geoffchappell.com/studies/windows/win32/apisetschema/index.htm) by Geoff Chappell

## Shellcode

- [Stardust](https://github.com/Cracked5pider/Stardust) by Cracked5pider
- 2024/01/27 [Modern implant design: position independent malware
  development](https://5pider.net/blog/2024/01/27/modern-shellcode-implant-design/) by 5pider
- https://defuse.ca/online-x86-assembler.htm

## Sleep Encryption

- 2017/03/04
  https://lospi.net/security/assembly/c/cpp/developing/software/2017/03/04/gargoyle-memory-analysis-evasion.html
- 2021/09/10
  https://www.solomonsklash.io/SleepyCrypt-shellcode-to-encrypt-a-running-image.html - https://github.com/SolomonSklash/SleepyCrypt
- 2022/04/23
  https://www.arashparsa.com/bypassing-pesieve-and-moneta-the-easiest-way-i-could-find/ - https://github.com/waldo-irc/YouMayPasser
- 2022/05/05 https://web.archive.org/web/20220625003531/https://suspicious.actor/2022/05/05/mdsec-nighthawk-study.html - https://github.com/Cracked5pider/Ekko
- 2022/07/30 https://github.com/janoglezcampos/DeathSleep
- 2022/08/29 https://icebreaker.team/blogs/sleeping-with-control-flow-guard/
- 2022/11/06 https://idov31.github.io/2022/11/06/cronos-sleep-obfuscation.html - https://github.com/Idov31/Cronos

- https://github.com/y11en/FOLIAGE (Original from https://github.com/SecIdiot/FOLIAGE)


## Syscalls

System calls or syscalls are a mean used for the user space code to request
actions to the kernel, so syscalls is the kernel API.

Here is how an x64 user mode program can invoke a syscall in assembly:
```x86asm
mov eax, 0x13
syscall
return
```

It is just necessary to specify the code of the syscall you want to invoke by
setting it in the `eax` register and then execute the instruction
`syscall`. This is how it works in x64, in other architectures the instruction
and register used to indicate the syscall can be different but the process
is similar.

Different OS manage syscalls in different ways. For example, in [Linux all the
syscall
codes](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)
remains the same in different versions, and they are usually invoked trough the
[libc](https://www.man7.org/linux/man-pages/man7/glibc.7.html), but also by
another libraries and a user program can invoke them by using the [syscall
function](https://www.man7.org/linux/man-pages/man2/syscall.2.html). On
the other hand, Windows [syscall
codes](https://j00ru.vexillium.org/syscalls/nt/64/) can change in different
versions of the OS, so the way it manages to avoid disruptions in user programs
is to handle all of them through the ntdll library, which exports a function for
each syscall and establish the correct syscall code for each version. For
example the `NtDelayExecution` syscall function (the one used by sleep) has the
syscall code or Service System Number (SSN) `0x31` in Windows 7 and `0x34` in
Windows 10.

You can check the SSN for the different Windows versions in theses tables (made
by j00ru):
- [Windows X86-64 System Call Table](https://j00ru.vexillium.org/syscalls/nt/64/)
- [Windows X86 System Call Table](https://j00ru.vexillium.org/syscalls/nt/32/)

Therefore is not common for Windows user applications to invoke syscalls
directly, but a more commom flow is to invoke functions of libraries like
kernel32 which in turn calls the ntdll syscall functions. Here is a very simple
diagram of the common flow from an user function to the kernel:
```
          .------------------.
          | User application |
          '------------------'
                  |
         .--------'
         v
   .----------.
   | Kernel32 |------------.
   '----------'            v
        |            .------------.
        |            | Kernelbase |
        |            '------------'
        |                  |
        v                  v
 .----------------------------------.
 |              NTDLL               |
 '----------------------------------'
User mode         |
-----------------------------------------------
Kernel mode       v
 .----------------------------------.
 |              Kernel              |
 '----------------------------------'

```

Since in Windows all the syscalls are managed by ntdll functions, EDR usually
hooks these functions in order to obtain telemetry to identify malware. In this
regard malware authors have been thinking how to bypass these hooks, and one
solution is made the syscalls themselves to bypass the ntdll (other solutions
can be unhook the ntdll, but that is not the subject in this section). This
arises two relevant questions:

- How do we obtain the syscall code or SSN?
- How do we invoke the syscall?

### Resolving Syscalls SSNs

Let's start by the first question. As we have seem syscalls are managed by
ntdll, so how ntdll knows each syscall SSN? Let's dive in the code of a
syscall to answer it. Here is the code of the `NtDelayExecution`:
```
0:000> u ntdll!NtDelayExecution
ntdll!NtDelayExecution:
00007ff8`e1fcdb60 4c8bd1          mov     r10,rcx
00007ff8`e1fcdb63 b834000000      mov     eax,34h
00007ff8`e1fcdb68 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
00007ff8`e1fcdb70 7503            jne     ntdll!NtDelayExecution+0x15 (00007ff8`e1fcdb75)
00007ff8`e1fcdb72 0f05            syscall
00007ff8`e1fcdb74 c3              ret
00007ff8`e1fcdb75 cd2e            int     2Eh
00007ff8`e1fcdb77 c3              ret
```

You can see that it moves the value `0x34` to `eax` and then, after a check, it
executes the `syscall` instruction. So, how ntdll knows each syscall SSN? They
are hardcoded into ntdll. So a way we have to extract each syscall number is to
examine all the syscall functions in ntdll and extract the SSN. Fortunately for
us, we know that all the syscalls start with `Nt` or `Zw` prefix, like
`NtDelayExecution` or `ZwDelayExecution`, which are the same function.

Enumeration of syscalls in ntdll with radare:
```bash
$ rabin2 -E ntdll.dll | grep Zw
1785 0x0009c920 0x18009d520 GLOBAL FUNC 0    ntdll.dll ZwAcceptConnectPort
1786 0x0009c8e0 0x18009d4e0 GLOBAL FUNC 0    ntdll.dll ZwAccessCheck
1787 0x0009ce00 0x18009da00 GLOBAL FUNC 0    ntdll.dll ZwAccessCheckAndAuditAlarm
1788 0x0009d530 0x18009e130 GLOBAL FUNC 0    ntdll.dll ZwAccessCheckByType
1789 0x0009d400 0x18009e000 GLOBAL FUNC 0    ntdll.dll ZwAccessCheckByTypeAndAuditAlarm
...
```

So we can just enumerate all the functions starting with `Zw`, examine them and
retrieve the SSN, which is in a fixed, since all the syscalls functions share
the same format. (In this regard is preferably look for the `Zw` prefix, since
some functions starting with `Nt` are not really syscalls.) This is the
technique applied by Hell's Gate: 

- 2020 [HellsGate](https://web.archive.org/web/20241001115826/https://vxug.fakedoma.in/papers/VXUG/Exclusive/HellsGate.pdf)
  by smelly__vx and [am0nsec](https://x.com/am0nsec)
- [HellsGate (tool)](https://github.com/am0nsec/HellsGate)
- 2022/03/09 [HellGate Technique on AV
  Bypass](https://rioasmara.com/2022/03/09/hellgate-technique-on-av-bypass/) by Rio Asmara Suryadi

This technique is very straightforward but the downside is that in case a
syscall function is hooked by an EDR or any other solution, then the syscall
number is removed by the patch, so making unable to retrieve the SSN. To avoid
this problem, some researchers become aware that they can deduce the SSN of a
syscall by checking the previous or next syscall SSN in memory, since the SSN
was decremented or incremented by one respectively, making possible to deduce
the SSN for the syscall we are looking for even if this was patched. This
technique is used by Halo's Gate:

- 2021/04/23 [Halo's Gate - twin sister of Hell's Gate](https://blog.sektor7.net/#!res/2021/halosgate.md)
- [TartarusGate (tool)](https://github.com/trickster0/TartarusGate)
- [RecycledGate (tool)](https://github.com/thefLink/RecycledGate)
- [AsmHalosGate (tool)](https://github.com/boku7/AsmHalosGate)

But an step further was taken in this regard when other researchers discover
(not neccesarily after the previous discovery) that was not even required to
examinate the ntdll syscalls functions in order to extract the SSNs, but it was
just possible to sort all the syscall functions by memory address order and the
position a syscall function held in that list is its SSN. This technique was
used by FreshyCalls and modexpblog:

- 2020/06/10 [FreshyCalls: Syscalls Freshly
  Squeezed!](https://web.archive.org/web/20220929111239/https://www.crummie5.club/freshycalls/)
  by ElephantSe4l
- 2020/12 [Bypassing User-Mode Hooks and Direct Invocation of System Calls for
  Red
  Teams](https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/)
  by [modexpblog](https://x.com/modexpblog)
- [FreshyCalls (tool)](https://github.com/crummie5/FreshyCalls)
- [SysWhispers2 (tool)](https://github.com/jthuraisamy/SysWhispers2)
- [SysWhispers3 (tool)](https://github.com/klezVirus/SysWhispers3)

After knowing that syscalls are sorted by memory address, modexpblog also
discovered that the runtime function table in ntdll contains a list of the
ntdll functions, among which are the syscall functions, sorted by memory
address. So instead of manually sort the syscall functions by address we can
just traverse that list to obtain the SSNs:

- 2022/04 [Resolving System Service Numbers using the Exception
  Directory](https://www.mdsec.co.uk/2022/04/resolving-system-service-numbers-using-the-exception-directory/)
  by [modexpblog](https://x.com/modexpblog)


### Invoking syscalls

Once we know what SSN corresponds to which syscall, we need to invoke the
syscall to communicate with the kernel. There are several ways to perform this
operation.

The most straightforward approach would be to just invoke the `syscall`
instruction (or whatever the instruction is in the CPU architecture). This
approach is known as **Direct Syscall** and is used in the following projects:

- [hellsgate.asm from
  HellsGate (tool)](https://github.com/am0nsec/HellsGate/blob/master/HellsGate/hellsgate.asm)
- [zsyscall (tool)](https://gitlab.com/Zer1t0/zsyscall)
- 2019-06-19 [Red Team Tactics: Combining Direct System Calls and sRDI to bypass
  AV/EDR](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/)
  by Cornelis

An issue from the previous approach is that is quite an anomaly to invoke a
syscall outside the ntdll, so an EDR can discover this suspicious behavior. A
way to avoid this issue is to jump to a syscall instruction from ntdll, so we
don't need to use it from our binary address. This is known as **Indirect
Syscall**. An example of this approach can be observed in the following
projects:

- [RecycledGate (tool)](https://github.com/thefLink/RecycledGate)
- [HellsHall (tool)](https://github.com/Maldev-Academy/HellHall)
- [BokuLoader (tool)](https://github.com/boku7/BokuLoader)


### Syscalls references

Here are some references that I didn't manage to insert in a specific section:

- 2022/01 [x86 Nirvana Hooks & Manual Syscall
  Detection](https://blog.xenoscr.net/2022/01/17/x86-Nirvana-Hooks.html) by
  Conor Richard
- 2021/02/10 [Detecting Manual Syscalls from User
  Mode](https://winternl.com/detecting-manual-syscalls-from-user-mode/) by winternl
- 2022/01/29 [EDR Bypass : Retrieving Syscall ID with Hell's Gate, Halo's Gate,
  FreshyCalls and
  Syswhispers2](https://alice.climent-pommeret.red/posts/direct-syscalls-hells-halos-syswhispers2/)
  by Alice
- 2022/03/24 [A Syscall Journey in the Windows
  Kernel](https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/)
  by Alice

