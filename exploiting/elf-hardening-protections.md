# ELF hardening protections

In order to prevent the exploitation of memory corruption vulnerabilities,
programs count with several protection mechanisms implemented by different
components, like the compiler and the libc, but also the kernel. This page
contains a description of the protections implemented by GNU/Linux, being many
of them also used in other Unix-like OS.


In order to check the protections available for a binary, we can use the
[checksec](https://manpages.ubuntu.com/manpages/focal/en/man1/checksec.1.html) utility:
```
checksec --file=/bin/ls
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   No Symbols	  Yes	5		17		/bin/ls
```

Another possibility is to use the [pwntools](https://github.com/Gallopsled/pwntools) checksec command:
```
$ pwn checksec /bin/ls
[*] '/bin/ls'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
```



## ASLR and PIE

In old programs, each symbol, like variables and functions, was referenced by
inserting its absolute memory address in the code. This implied that the binary
needed to be load always at the same memory address, which posed several
problems. First, this could create conflicts if two libraries needed to be load at
the same address, and second, in case of a memory corruption vulnerability it
was easy for an attacker to know the exact address to redirect the execution flow
since they were the same in different program executions.

Therefore, in order to avoid the previous issues, the compilers added an option
to generate PIE (Position Independent Code), that is code that includes
references to symbols (variables and functions) as offsets relative to the
current instruction instead of using absolute memory addresses. This allows the
code to be placed at any address.

We will use the following program as example, which we will compile and verify
if it is PIE or not:
```c
// main-address.c
#include <stdio.h>

void main() {
    printf("main is at %p\n", main);
}
```

By default gcc compiles with PIE enabled, but we can control the behavior with
the `-pie/-no-pie` options. Let's see examples of both PIE and non PIE
programs characteristics and behaviors (with ASLR enabled).

Here is an example of a non PIE program:
```
$ gcc -no-pie main-address.c -o main-address-no-pie
$ readelf --file-header main-address-no-pie | grep Type
  Type:                              EXEC (Executable file)
$ for i in {1..3}; do ./main-address-no-pie; done
main is at 0x401126
main is at 0x401126
main is at 0x401126
```

And here we have a PIE program:
```
$ gcc -pie main-address.c -o main-address-pie
$ readelf --file-header main-address-pie | grep Type
  Type:                              DYN (Position-Independent Executable file)
$ for i in {1..3}; do ./main-address-pie; done
main is at 0x564bffe33139
main is at 0x55f5fcc53139
main is at 0x5560dd9d1139
```

As we can see the **type in the ELF header differs** in case of PIE or not, and
when executed, the **PIE program changes its addresses** (ASLR is enabled).

Additionally to PIE, operating systems added ASLR (Address Space Layout
Randomization) that randomizes the address at which a binary, program and/or
library, is loaded. **ASLR can only be applied to PIE binaries**.

We can check if ASLR is enabled by reading `/proc/sys/kernel/randomize_va_space`
file value:
```
$ cat /proc/sys/kernel/randomize_va_space
2
```

There are three possible [values for randomize_va_space](https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#randomize-va-space):
- **0**: ASLR is disabled
- **1**: Randomization is enabled for stack , [vdso](https://www.man7.org/linux/man-pages/man7/vdso.7.html) and [mmap](https://www.man7.org/linux/man-pages/man2/mmap.2.html) addresses,
  that implies that shared libraries will be loaded at random addresses.
- **2**: The same as 1 but also the [brk](https://www.man7.org/linux/man-pages/man2/brk.2.html) syscall is randomize, making the
  data segment or heap addresses random. This is the default value in modern
  systems.

In case we want to disable ASLR (for testing), we just need to write a zero
value into `/proc/sys/kernel/randomize_va_space`:
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

We can use the example of the previous PIE program to check what happens when
ASLR is disabled:
```
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
0
(fsv) ada@king:~/projects/elf-hardening
$ for i in {1..3}; do ./main-address-pie; done
main is at 0x555555555139
main is at 0x555555555139
main is at 0x555555555139
```

As we can see, even if the program is PIE, if we disable ASLR, the start address
is the same for all its executions.

And here is the program with PIE and ASLR enabled:
```
$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
2
(fsv) ada@king:~/projects/elf-hardening
$ for i in {1..3}; do ./main-address-pie; done
main is at 0x55a6a635f139
main is at 0x55ea361ac139
main is at 0x564e69e4b139
```

And here we have again all the randomization.

And lastly, **it is possible to disable ASLR only for an specific process**, by using
the [personality syscall](https://www.man7.org/linux/man-pages/man2/personality.2.html). In fact, this is done by GDB by default when we
debug the program with it:

```
$ gdb -q main-address-pie -ex "run" -ex "run" -ex "run" -ex "quit" | grep "main is at"
main is at 0x555555555139
main is at 0x555555555139
main is at 0x555555555139
```

In case we want to use ASLR when debugging with GDB, we can enable ASLR by using
the `set disable-randomization off` command:
```
$ gdb -q main-address-pie -ex "set disable-randomization off" -ex "run" -ex "run" -ex "run" -ex "quit" | grep "main is at"
main is at 0x55d07a383139
main is at 0x55f5d1bd9139
main is at 0x5633e72c8139
```

## NX

The Non eXecutable stack or NX protection, makes the stack memory region non
executable, by giving it just read and write permissions. This **prevents
malicious shellcodes from being executed directly from the stack**.

We can discover if a program has NX enabled by reading the program header
`GNU_STACK` (for this example we will use the program from the previous
section):
```
$ readelf -l main-address-pie | grep STACK -A 1
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
```

In this case we see that `GNU_STACK` has `RW` permissions that allows to read and
write, but not to execute. When the program is going to be executed, the loader
will take this information into account a made the stack section non executable.

However, if for some reason we want to disable NX, we can compile a program with
the `-z execstack` option (in this case we compile the program example from the
previous section):
```
$ gcc main-address.c -z execstack -o main-address-no-nx
$ readelf -l main-address-no-nx | grep STACK -A 1
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RWE    0x10
```

We can see that the permissions now are `RWE` for `GNU_STACK`, indicating that
the stack will be executable.

## Stack canary

A common technique in exploiting to control the program flow is to overwrite the
return address of a function, that is stored in the stack. Usually this is done
by overflowing a local variable, also stored in the stack in lower address,
until the attacker reaches the return address, overwriting everything between
the local variable and the return address.

Knowing this, a mechanism created to prevent successful exploitation after the
stack is overwritten is the stack canary. The stack canary consists of a value,
known as canary or stack cookie or stack guard, that is inserted into the stack
between the return address and the local variables when the function begins, and
it is checked at the end of the function, just before jumping into the return
address. If the canary value was modified by the function, then the program
aborts.

Therefore, when using stack canary, the shape of the stack frame in the
middle of the function should be something like this:
```
higher addresses

  |     ....       |
  |----------------|
  | return address |
  | -------------- |
  |  previous rbp  |
  | -------------- |
  |     canary     |
  | -------------- |
  |   local vars   |
  |      ....      |
  |      ....      |

lower addresses
```

We can see that the canary is set between the local variables, that are the
ones that could be overflowed, and the return address. Thus, if after a local
variable overflow the canary has changed, then the program aborts its
execution.

Let's compile the following example to check it:
```c
// stack-canary.c
#include <stdio.h>

void print_name(int len) {
  char name[10] =  { 0 };
  fgets(name, len, stdin);
  printf("Your name is %s\n", name);
}

void main() {
  print_name(100);
}
```

As we can see this program asks for a name that is inserted in a local variable
with just 10 bytes of space, but allow us to insert until 100 characters.

First, we need to compile the program with stack canary, that is not included by
default in gcc. For compiling with stack canary, we have several options:
- [-fstack-protector](https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Instrumentation-Options.html#index-fstack-protector): Only the vulnerable functions are protected.
- [-fstack-protector-all](https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Instrumentation-Options.html#index-fstack-protector-all): All the functions are protected.
- [-fstack-protector-explicit](https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Instrumentation-Options.html#index-fstack-protector-explicit): Only the functions marked with
  [stack_protect](https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Common-Function-Attributes.html#index-stack_005fprotect-function-attribute) are protected.

Here we will use the basic stack protector:
```
$ gcc -fstack-protector stack-canary.c -o stack-canary-enable
```

Once compiled, we can verify the stack canary is in place by looking for the
import of the `__stack_chk_fail` function, that is the one that checks if the
stack canary was corrupted:
```
$ readelf --symbols stack-canary-enable | grep __stack_chk_fail
    24: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail[...]
```

Finally, we can try to overflow the stack by passing a name with more than 10
characters:
```
$ perl -e 'print "A"x50' | ./stack-canary-enable
Your name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
*** stack smashing detected ***: terminated
Aborted (core dumped)
```

As we can see, the program prints a message indicating that the stack was
corrupted, since the value of the canary has changed after the name overflow.

If we are curious, we can check the generated code for the function `print_name`:
```
$ gdb -q stack-canary-enable -ex "set pagination off" \
    -ex "set disassembly-flavor intel" -ex "disassemble print_name" -ex "quit"
Reading symbols from stack-canary-enable...
(No debugging symbols found in stack-canary-enable)
Dump of assembler code for function print_name:
   0x0000000000001159 <+0>:	push   rbp
   0x000000000000115a <+1>:	mov    rbp,rsp
   0x000000000000115d <+4>:	sub    rsp,0x30
   0x0000000000001161 <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x0000000000001164 <+11>:	mov    rax,QWORD PTR fs:0x28
   0x000000000000116d <+20>:	mov    QWORD PTR [rbp-0x8],rax
   ...stripped...
   0x00000000000011c4 <+107>:	call   0x1030 <__stack_chk_fail@plt>
   0x00000000000011c9 <+112>:	leave
   0x00000000000011ca <+113>:	ret
End of assembler dump.
```

We can see the instruction `mov rax,QWORD PTR fs:0x28` that copies into
`rax` a random stack canary value from [an internal glibc TLS structure](https://github.com/bminor/glibc/blob/81467d4b6168c7ce40d951d6b32e387109c0e5ae/sysdeps/x86_64/nptl/tls.h#L51C3-L51C12). In
this case the canary value (or stack guard) is randomly generated in each
execution of the program. Then the canary is copied into the stack by
`mov QWORD PTR [rbp-0x8],rax`.

Finally, after the function is executed, the `__stack_chk_fail` function is
called to verify the integrity of the stack. If the stack is corrupted, the
program aborts with the `*** stack smashing detected ***: terminated` message
that we have seen above.

However, if we compile the same program without the stack canary protection, we
can see that the canary checks are not in place:
```
$ gcc -fno-stack-protector stack-canary.c -o stack-canary-disable
(fsv) ada@king:~/projects/elf-hardening
$ gdb -q stack-canary-disable -ex "set pagination off" \
    -ex "set disassembly-flavor intel" -ex "disassemble print_name" -ex "quit"
Reading symbols from stack-canary-disable...
(No debugging symbols found in stack-canary-disable)
Dump of assembler code for function print_name:
   0x0000000000001149 <+0>:	push   rbp
   0x000000000000114a <+1>:	mov    rbp,rsp
   0x000000000000114d <+4>:	sub    rsp,0x20
   0x0000000000001151 <+8>:	mov    DWORD PTR [rbp-0x14],edi
   0x0000000000001154 <+11>:	mov    QWORD PTR [rbp-0xa],0x0
   0x000000000000115c <+19>:	mov    WORD PTR [rbp-0x2],0x0
   0x0000000000001162 <+25>:	mov    rdx,QWORD PTR [rip+0x2eb7]        # 0x4020 <stdin@GLIBC_2.2.5>
   0x0000000000001169 <+32>:	mov    ecx,DWORD PTR [rbp-0x14]
   0x000000000000116c <+35>:	lea    rax,[rbp-0xa]
   0x0000000000001170 <+39>:	mov    esi,ecx
   0x0000000000001172 <+41>:	mov    rdi,rax
   0x0000000000001175 <+44>:	call   0x1040 <fgets@plt>
   0x000000000000117a <+49>:	lea    rax,[rbp-0xa]
   0x000000000000117e <+53>:	mov    rsi,rax
   0x0000000000001181 <+56>:	lea    rax,[rip+0xe7c]        # 0x2004
   0x0000000000001188 <+63>:	mov    rdi,rax
   0x000000000000118b <+66>:	mov    eax,0x0
   0x0000000000001190 <+71>:	call   0x1030 <printf@plt>
   0x0000000000001195 <+76>:	nop
   0x0000000000001196 <+77>:	leave
   0x0000000000001197 <+78>:	ret
End of assembler dump.
```

Additionally, we must know that there are several versions of stack canary
value. Here are some of them:

- **Null value**:  A canary value that is zero. This can be bypassed easily.

- **Terminator value**: Similar to the null value, but the last byte changes to a
  value like 0xa or 0xff. This can be easily bruteforced.

- **Random value**: A canary value that is randomly generated when the program
  starts. This is the one used by GCC. This is still have issues, since the
  canary could be leaked, for example, with a format string
  vulnerability. Additionally, in case a program forks, the child will have the
  same canary value.

- **XORed random value**: Similar to the previous one, but the random canary value
  is xored with a register, commonly *ebp*. The good thing about this is that
  the value can change in different functions, however sometimes the register
  will have the same value, as is the case of *ebp* when the function is called
  following the same call path. For example if the call path to `print_name` is
  `main -> print_name`, *ebp* will be at the same position always for this
  execution path, whereas will at another position if the execution path changes
  like `main -> print_several_names -> print_name`. So *ebp* gives variation
  for different execution paths, but will be always the same for a given
  execution path in the same process (and forked ones).


Moreover, as we have commented, the stack canary protection can be bypassed. For
example, if we are able to leak its value, by using a format string
vulnerability for example, we will probably be able to bypass it, since we just
need to add to our payload the value of the stack canary at the exact position.
Another option if we have arbitrary memory writing capabilities, with a format
string vulnerability for example, is to overwrite only the return address
without touching the rest of the stack, so the canary is kept intact. And
finally, we can consider alternatives to overwrite the return address, like the
GOT table or C++ virtual tables.

### Stack canary resources
- 04/05/2020 [Exploit Mitigation Techniques - Part 2 - Stack Canaries](https://0x434b.dev/an-introduction-to-data-stack-canaries-in-linux/) by 0x434b

## RELRO

RELRO (Relocation Read-Only) is a protection mechanism that makes the GOT
(Global Address Table) read-only. There are two levels:

- Partial RELRO: Just make the .got section (that contains the location of
  external variables) readonly.

- Full RELRO: Makes also .got.plt (that contains the address of external
  functions) readonly. This is the one that really prevents GOT overwrite.

Here is our example program:
```c
//relro.c
#include <stdio.h>

void main() {
  printf("Hello World\n");
}
```

First, we will compile it just with partial RELRO (which is the default if
nothing in this regard is specified) by specifying the `-Wl,-z,relro` option:
```
$ gcc -g -Wl,-z,relro relro.c -o relro-partial
```

Then we can verify the binary was compiled with RELRO by looking for the
`GNU_RELRO` segment:
```
$ readelf --segments relro-partial | grep RELRO -A 1
  GNU_RELRO      0x0000000000002dd0 0x0000000000003dd0 0x0000000000003dd0
                 0x0000000000000230 0x0000000000000230  R      0x1
```

Additionally, to obtain full RELRO we need to specify the `-Wl,-z,relro,-z,now`
options:
```
$ gcc -g -Wl,-z,relro,-z,now relro.c -o relro-full
```

In this occasion, we can [detect full RELRO](https://github.com/Gallopsled/pwntools/blob/d1021e764e9dc346d34e618b7055823a025c83c7/pwnlib/elf/elf.py#L1784C21-L1784C30) by searching for the flag
`BIND_NOW` in the dynamic section of the binary:
```
$ readelf --segments relro-full | grep RELRO -A 1
  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000248 0x0000000000000248  R      0x1
$ readelf --dynamic relro-full | grep BIND_NOW
 0x000000000000001e (FLAGS)              BIND_NOW
```

`BIND_NOW` indicates that the .got.plt section is going to be readonly and
therefore the program must bind the external functions addresses at the
beginning of the program, instead of using the lazy binding approach.


### RELRO resources
- 28/01/2019 [Hardening ELF binaries using Relocation Read-Only (RELRO)](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro) by
  Huzaifa Sidhpurwala

## Fortify

Fortify is a protection that allows the glibc to use hardened versions of common
functions in case the compiler considers a function vulnerable to an attack. The
hardened versions can be identified since they finish with the `_chk` suffix,
for example, the hardened version of `fgets` is `__fgets_chk`.

Let's check the following example that asks for our name and surname:
```c
// fortify.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(int argc, char** argv) {
  char name[20] = { 0 };
  char* name_ptr;
  char* ign;

  name_ptr = name;

  printf("Introduce your name: ");
  ign = fgets(name_ptr, 11, stdin);
  name_ptr += strlen(name);

  // add separator between name and surname
  strcat(name_ptr, " ");
  name_ptr++;

  printf("Introduce your surname: ");
  ign = fgets(name_ptr, 11, stdin);

  printf(name);
}
```

You may notice that there is an off by one buffer overflow when given a name and
surname of maximum length, 10 characters each, as well as a format string
vulnerability.

Let's compile this program with fortify. For this we need to specify a level of
protection from 1 to 3 by using the `_FORTIFY_SOURCE` definition, the higher the
number the stronger the protection. Based on the level of protection chosen, the
glibc and the compiler work together to select the appropriate version of libc
functions, regular or hardened (end with `_chk`).

Here we are going to compile with `_FORTIFY_SOURCE=3` that is the current
maximum level available. Additionally we need to enable optimization, with the
`-O` option, for fortify to work:
```
$ gcc -O -D_FORTIFY_SOURCE=3 fortify.c -o fortify
```

Once compiled we can verify that the hardened versions were added to our program:
```
$ readelf --symbols fortify | grep "_chk"
    18: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __strcat_chk@GLI[...]
    33: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __fgets_chk@GLIBC_2.4
    36: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __printf_chk@GLI[...]
```

Now let's try to overflow the name:
```
$ echo "AAAAABBBBBCCCCCDDDDD" | ./fortify
*** buffer overflow detected ***: terminated
Aborted (core dumped)
```

The overflow was detected. We can also check that some protections against
format string vulnerabilities are in place:
```
$ echo "%n" | ./fortify
*** %n in writable segment detected ***
Aborted (core dumped)
```

However seems we can still use the format string to dump the stack:
```
$ echo "%p|%p|%p|" | ./fortify
Introduce your name: Introduce your surname: 0xfbad2098|0x7ffca39fd68b|0x1|
```

### Fortify resources
- 26/03/2014 [Enhance application security with FORTIFY_SOURCE](https://www.redhat.com/en/blog/enhance-application-security-fortifysource) by Siddharth
  Sharma
- 14/10/2022 [Broadening compiler checks for buffer overflows in _FORTIFY_SOURCE](https://developers.redhat.com/blog/2021/04/16/broadening-compiler-checks-for-buffer-overflows-in-_fortify_source) by Siddhesh Poyarekar
- 4/07/2023 [A developer’s guide to secure coding with FORTIFY_SOURCE](https://developers.redhat.com/articles/2023/07/04/developers-guide-secure-coding-fortifysource) by Sandipan Roy
- 6/02/2023 [How to improve application security using _FORTIFY_SOURCE=3](https://developers.redhat.com/articles/2023/02/06/how-improve-application-security-using-fortifysource3) by Siddhesh Poyarekar

## Resources

- 14/11/2023 [Part 2 — Compiler Level Security Mechanisms (GCC)](https://medium.com/@ofriouzan/part-2-compiler-level-security-mechanisms-gcc-d01246b8d157) by Ofri Ouzan
- [Arch package guidelines/Security](https://wiki.archlinux.org/title/Arch_package_guidelines/Security)
