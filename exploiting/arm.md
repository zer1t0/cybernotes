# ARM

## Learning ARM

The following tutorial is a nice one to start with ARM:

- [ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/) by Azeria

The tutorial is based in armhf, so if you want to do it in an arm64 OS, you may
want to check the [Compiling and Running armhf in arm64](#compiling-and-running-armhf-in-arm64) section.

> **Troubleshooting**: When using gdb to debug ARM examples a problem with
> debugging `_start` function can arise:
> [Assertion buffer.copy_insn_closure.get () != nullptr failed](https://sourceware.org/bugzilla/show_bug.cgi?id=30872). We can use
> the `set displaced-stepping off` gdb command to avoid this problem.

Other resources:
- 31/01/2011 [EXPLOITING ARM LINUX SYSTEMS An introduction](https://crossbowerbt.github.io/docs/exploiting_arm/exploiting_arm_linux_systems.pdf) by Emanuele Acri

## ARM architectures

There are several [ARM architectures](https://en.wikipedia.org/wiki/ARM_architecture_family#Cores), being the most used the ARMv7, for
32-bits, and the ARMv8 that introduces the 64-bit.

Moreover, apart from the ARM architectures, there are different
[ARM ports to GNU/Linux](https://www.debian.org/ports/arm/) that are use to classify ARM:

- [arm64](https://wiki.debian.org/Arm64Port) or **aarch64**: 64 bit ARM (64 bit mode starts in ARMv8-A). This is the one
  used in 64-bit Raspbian.
- [armhf](https://wiki.debian.org/ArmHardFloatPort): ARM hard float is a 32 bit ARM (usually ARMv7) that supports
  hardware floating point. This is the one used in 32-bit Raspbian.
- [armel](https://wiki.debian.org/ArmEabiPort): Is an 32 bit ARM used in older machines.


### Distinguish binaries between ARM architectures

We can use the [file](https://man.archlinux.org/man/file.1), [readelf](https://man.archlinux.org/man/readelf.1.en) or [objdump](https://man.archlinux.org/man/objdump.1) tools to inspect the ARM
executable and determine its architecture.
x

Here is a sample of the output for *armel*:
```
$ readelf -h main-armel | grep -E 'Class|Machine|Flags'
  Class:                             ELF32
  Machine:                           ARM
  Flags:                             0x5000200, Version5 EABI, soft-float ABI

$ file main-armel
main-armel: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux.so.3,
BuildID[sha1]=6ce19d97b9e0eb8eb7fcd25126af40fb43c53679, for GNU/Linux 3.2.0,
not stripped
```


Output for *armhf*:
```
$ readelf -h main-armhf | grep -E 'Class|Machine|Flags'
  Class:                             ELF32
  Machine:                           ARM
  Flags:                             0x5000400, Version5 EABI, hard-float ABI

$ file main-armhf
main-armhf: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux-armhf.so.3,
BuildID[sha1]=18a116672f8bbc52da755ed71f5a04e11e651aa2, for GNU/Linux 3.2.0,
not stripped
```

We can see that both *armel* and *armhf* are 32 bits, the main difference in the
ELF file is that the flags of *armhf* indicate `hard-float ABI` (remember that
*armhf* stands for ARM hard float) whereas *armel* indicate `soft-float
ABI`.

Additionally the *armel* interpreter is `/lib/ld-linux.so.3` whereas the
one for *armhf* is `/lib/ld-linux-armhf.so.3`. This could change in other
machines, so prefer inspect the ELF header, but it is a good indicator.

Output for `aarch64`:
```
$ readelf -h main-aarch64 | grep -E 'Class|Machine|Flags'
  Class:                             ELF64
  Machine:                           AArch64
  Flags:                             0x0

$ file main-aarch64
main-aarch64: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux-aarch64.so.1,
BuildID[sha1]=e6c020bdb4e86a8bc8604503f42ea446a9f09bbb, for GNU/Linux 3.7.0,
not stripped
```

In case of *aarch64* we can appreciate that both commands state clearly that is
an `aarch64` architecture.


## Compiling and Running armhf in arm64

We can compile and run armhf (32 bits) software into arm64 (at least in a
Rasperry Pi).

In order to compile for armhf, we need to install the proper gcc cross compiler:
```
sudo apt install gcc-arm-linux-gnueabihf
```

> **Warning**: The `gcc-arm-linux-gnueabi` package is for armel, not for
> armhf. So if you compile with `arm-linux-gnueabi-gcc` programs won't work
> with the following configuration (at least in Raspbian).

We can try to cross compile the following c program:
```c
#include <stdio.h>

void main() {
	printf("Hello world\n");
}
```

We can compile it with `arm-linux-gnueabihf-gcc`:
```
arm-linux-gnueabihf-gcc hello.c -o hellohf
```

And we can verify that the output binary is armhf:
```
$ file hellohf
hellohf: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically
linked, interpreter /lib/ld-linux-armhf.so.3,
BuildID[sha1]=32815b3f0566587a8de27af5316369d9394d5d13, for GNU/Linux 3.2.0, not
stripped
```

We must notice that the output indicates an 32-bit executable and the
interpreter is `/lib/ld-linux-armhf.so.3`, indicating we have an armhf
program.

Then, in order to run the armhf programs, we need to add the armhf architecture
and install the proper libc library:
```
sudo dpkg --add-architecture armhf
sudo apt-get install libc6:armhf
```

And then we can run it:
```
$ ./hellohf
Hello world
```

## ARM shellcode

- 2009 [Alphanumeric RISC ARM Shellcode](https://phrack.org/issues/66/12) by Yves Younan and Pieter Philippaerts
- 2017 [Introduction to Writing ARM Shellcode](https://azeria-labs.com/writing-arm-shellcode/) by Azeria

### ARM shellcode: data cache and instruction cache

When executing a shellcode in an armhf challenge ([stack5 from protostar](https://web.archive.org/web/20140405135301/http://exploit-exercises.com/protostar/stack5)
with executable stack and ASLR disabled specifically), after crafting the
shellcode and working perfectly under gdb, in raised the following exception:
```
$ ./stack5 < <(perl -e 'print "\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x49\x40\x52\x40\xc2\x71\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x01" . "b"x40 . "\xb0\xf1\xfe\xff"')
Illegal instruction
```

After some digging, the issue came from the use of data and instructions cache
by ARM.

Some ARM processors have two separated caches for data (D-cache) and
instructions (I-cache). From my experience the D-cache and I-cache are present
in armhf, aka armv7, but not sure other versions.

The problem when executing a shellcode in one of these ARM processors is that we
need to force that, first the shellcode bytes (data) are written to the memory
and not just keep on the data cache, and then the instruction cache is refreshed
with our data (that I think it will happen automatically unless we overwrite
other code, which is weird).

In order to indicate a program to clear the data and instruction cache, the
glibc exports the [cacheflush](https://www.man7.org/linux/man-pages/man2/cacheflush.2.html) function in certain architectures, but in my
experience this is not the case in ARM. The alternative is to use the
[__builtin___clear_cache(void *begin, void *end)](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005f_005f_005fclear_005fcache) function introduced by GCC
in your code, that in case of armhf translates to a call to the function
`__clear_cache` introduced by GCC. `__clear_cache` in turn calls the
[cacheflush](https://www.man7.org/linux/man-pages/man2/cacheflush.2.html) syscall, as we can see in the following snippet:

```
Dump of assembler code for function __clear_cache:
   0x000008ec <+0>:	push	{r7}
   0x000008ee <+2>:	movw	r7, #2
   0x000008f2 <+6>:	movt	r7, #15
   0x000008f6 <+10>:	mov.w	r2, #0
   0x000008fa <+14>:	svc	0
   0x000008fc <+16>:	pop	{r7}
   0x000008fe <+18>:	bx	lr
```

We can see that *r7* stores the value `0xf0002` that corresponds with the
cacheflush syscall number defined for armhf:
```
$ grep -n cache -B 2 /usr/include/arm-linux-gnueabihf/asm/unistd.h
33-#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
34-#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
35:#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
```

In fact, when I added as a test the `__builtin_clear_cache` function to the
stack5 code (as the following snippet indicates), it make my exploit work
perfectly.
```c
#include <stdio.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
  __builtin___clear_cache(buffer, buffer + 72);
}
```

Another alternative seems to use the MCR instruction to indicate the MMU (Memory
Management Unit) to invalidate the data cache: [Understanding MRC on ARM7](https://stackoverflow.com/questions/19544694/understanding-mrc-on-arm7).

Another option seems to call [mprotect](https://www.man7.org/linux/man-pages/man2/mprotect.2.html) before execute the shellcode can
also work but in my experience it only does if it actually changes the memory
permissions. For example, if we write a shellcode in an `rw` area and we make it
`rwx`, then the cache are invalidated, but if we write somehow in a `rwx` area
and then make it `rwx` again (we don't change anything), the cache is not
refreshed. This shouldn't be a problem since most of the times the shellcodes
are written in `rw` areas.

And finally the another option it is to call [sleep](https://www.man7.org/linux/man-pages/man3/sleep.3.html) or a similar one, for my
exploit in the stack5 exercise I called [usleep](https://www.man7.org/linux/man-pages/man3/usleep.3.html) before my shellcode (located
in the executable stack) and it worked.

- 2019 [Why is My Perfectly Good Shellcode Not Working?: Cache Coherency on MIPS and ARM](https://web.archive.org/web/20191212201746/https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm)
- 2013 [Caches and Self-Modifying Code](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/caches-and-self-modifying-code)
- 2014 [Android Hackers Handbook: Chapter 9 - Separate Code and Instruction Cache](https://archive.org/details/AndroidHackersHandbook/page/n323/mode/2up
)
