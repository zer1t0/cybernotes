# ARM

## Learning ARM

The following tutorial is a nice one to start with ARM:

- [ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/) by Azeria

The tutorial is based in armhf, so if you want to do it in an arm64 OS, you may
want to check the [Compiling and Running armhf in arm64](#compiling-and-running-armhf-in-arm64) section.

> **Troubleshooting**: When using gdb to debug ARM examples a problem with
> debugging `_start` function can arise:
> [Assertion buffer.copy_insn_closure.get () != nullptr failed](https://sourceware.org/bugzilla/show_bug.cgi?id=30872). We can use
> the `set displaced-stepping off` gdb command to avoid this problem.

Other resources:
- 31/01/2011 [EXPLOITING ARM LINUX SYSTEMS An introduction](https://crossbowerbt.github.io/docs/exploiting_arm/exploiting_arm_linux_systems.pdf) by Emanuele Acri

## ARM architectures

There are several [ARM architectures](https://en.wikipedia.org/wiki/ARM_architecture_family#Cores), being the most used the ARMv7, for
32-bits, and the ARMv8 that introduces the 64-bit.

Moreover, apart from the ARM architectures, there are different
[ARM ports to GNU/Linux](https://www.debian.org/ports/arm/) that are use to classify ARM:

- [arm64](https://wiki.debian.org/Arm64Port) or **aarch64**: 64 bit ARM (64 bit mode starts in ARMv8-A). This is the one
  used in 64-bit Raspbian.
- [armhf](https://wiki.debian.org/ArmHardFloatPort): ARM hard float is a 32 bit ARM (usually ARMv7) that supports
  hardware floating point. This is the one used in 32-bit Raspbian.
- [armel](https://wiki.debian.org/ArmEabiPort): Is an 32 bit ARM used in older machines.


### Distinguish binaries between ARM architectures

We can use the [file](https://man.archlinux.org/man/file.1), [readelf](https://man.archlinux.org/man/readelf.1.en) or [objdump](https://man.archlinux.org/man/objdump.1) tools to inspect the ARM
executable and determine its architecture.
x

Here is a sample of the output for *armel*:
```
$ readelf -h main-armel | grep -E 'Class|Machine|Flags'
  Class:                             ELF32
  Machine:                           ARM
  Flags:                             0x5000200, Version5 EABI, soft-float ABI

$ file main-armel
main-armel: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux.so.3,
BuildID[sha1]=6ce19d97b9e0eb8eb7fcd25126af40fb43c53679, for GNU/Linux 3.2.0,
not stripped
```


Output for *armhf*:
```
$ readelf -h main-armhf | grep -E 'Class|Machine|Flags'
  Class:                             ELF32
  Machine:                           ARM
  Flags:                             0x5000400, Version5 EABI, hard-float ABI

$ file main-armhf
main-armhf: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux-armhf.so.3,
BuildID[sha1]=18a116672f8bbc52da755ed71f5a04e11e651aa2, for GNU/Linux 3.2.0,
not stripped
```

We can see that both *armel* and *armhf* are 32 bits, the main difference in the
ELF file is that the flags of *armhf* indicate `hard-float ABI` (remember that
*armhf* stands for ARM hard float) whereas *armel* indicate `soft-float
ABI`.

Additionally the *armel* interpreter is `/lib/ld-linux.so.3` whereas the
one for *armhf* is `/lib/ld-linux-armhf.so.3`. This could change in other
machines, so prefer inspect the ELF header, but it is a good indicator.

Output for `aarch64`:
```
$ readelf -h main-aarch64 | grep -E 'Class|Machine|Flags'
  Class:                             ELF64
  Machine:                           AArch64
  Flags:                             0x0

$ file main-aarch64
main-aarch64: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV),
dynamically linked, interpreter /lib/ld-linux-aarch64.so.1,
BuildID[sha1]=e6c020bdb4e86a8bc8604503f42ea446a9f09bbb, for GNU/Linux 3.7.0,
not stripped
```

In case of *aarch64* we can appreciate that both commands state clearly that is
an `aarch64` architecture.


## Registers on ARM

- Function args are passed in **r0-r3**, then the stack is used
- Function result is returned in **r0**
- The return address is passed in register **lr**, set by instruction
  `bl`. In case the called function is a leaf function (not other
  functions are called from this one), then the return address is
  keeped in lr, otherwise is stored in the stack, therefore allowing
  stack overflow vulnerabilities to take control of pc like x86.

Here is an overview of purpose of registers:

| Register | Usage                          |
|----------|--------------------------------|
| R0       | Return result, First parameter |
| R1       | Second parameter               |
| R2       | Third parameter                |
| R3       | Forth parameter                |
| R4       |                                |
| R5       |                                |
| R6       |                                |
| R7       |                                |
| R8       |                                |
| R9       |                                |
| R10      |                                |
| R11 / FP | Frame pointer                  |
| R12 / IP |                                |
| R13 / SP | Stack pointer                  |
| R14 / LR | Link register                  |
| R15 / PC | Program counter                |
| CSRP     | Contais the flags              |
|          |                                |


## Compiling and Running armhf in arm64

We can compile and run armhf (32 bits) software into arm64 (at least in a
Rasperry Pi).

In order to compile for armhf, we need to install the proper gcc cross compiler:
```
sudo apt install gcc-arm-linux-gnueabihf
```

> **Warning**: The `gcc-arm-linux-gnueabi` package is for armel, not for
> armhf. So if you compile with `arm-linux-gnueabi-gcc` programs won't work
> with the following configuration (at least in Raspbian).

We can try to cross compile the following c program:
```c
#include <stdio.h>

void main() {
	printf("Hello world\n");
}
```

We can compile it with `arm-linux-gnueabihf-gcc`:
```
arm-linux-gnueabihf-gcc hello.c -o hellohf
```

And we can verify that the output binary is armhf:
```
$ file hellohf
hellohf: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically
linked, interpreter /lib/ld-linux-armhf.so.3,
BuildID[sha1]=32815b3f0566587a8de27af5316369d9394d5d13, for GNU/Linux 3.2.0, not
stripped
```

We must notice that the output indicates an 32-bit executable and the
interpreter is `/lib/ld-linux-armhf.so.3`, indicating we have an armhf
program.

Then, in order to run the armhf programs, we need to add the armhf architecture
and install the proper libc library:
```
sudo dpkg --add-architecture armhf
sudo apt-get install libc6:armhf
```

And then we can run it:
```
$ ./hellohf
Hello world
```

## ARM user application emulation

In case we want to run a little ARM program in x86 machine, we can try to use
QEMU user mode emulation, that allows us to emulate programs without
dependencies (or maybe even with certain dependencies). Let's see how.

First, we need to install the QEMU user space emulator:
```
sudo apt update
sudo apt install qemu-user
```

With just qemu-user we can execute static ARM applications. Let's try it.

We are going to compile an application to test, for this we need the ARM
cross compiler. We have several options based on the ARM architecture we target:
- gcc-arm-linux-gnueabi: Cross compiler for armel
- gcc-arm-linux-gnueabihf: Cross compiler for armhf
- gcc-aarch64-linux-gnu: Cross compiler for aarch64

In this case we are going do the example with armel:
```
sudo apt install gcc-arm-linux-gnueabi
```

Here is the example code:
```c
// armel-example.c
#include <stdio.h>

void main(){
	printf("Hello from armel\n");
}
```

We can compile the program with `arm-linux-gnueabi-gcc`. We are going to use the
`-static` flag in order to create an static binary:
```
arm-linux-gnueabi-gcc armel-example.c -static -o armel-example-static
```

Then we can execute the armel program with:
```
$ qemu-arm armel-example-static
Hello from armel
```

> **Note**: We will use qemu-aarch64 to emulate an ARM 64 binary

We can also try to compile a dynamic binary:
```
arm-linux-gnueabi-gcc armel-example.c -o armel-example-dynamic
```

But we will get an error when execute it:
```
$ qemu-arm armel-example-dynamic
qemu-arm: Could not open '/lib/ld-linux.so.3': No such file or directory
```

This error indicates that we need to have the proper interpreter (dynamic
linker) for the program to execute. Good news is we can install the interpreter
with the following commands ([in Debian 12](https://wiki.debian.org/QemuUserEmulation)):
```
sudo dpkg --add-architecture armel
sudo apt update
sudo apt install libc6:armel
```

And if we try again:
```
$ qemu-arm armel-example-dynamic
Hello from armel
```

It could also happen that a dynamic binary indicates that the interpreter is in
a different location:
```
$ qemu-arm armel-external
qemu-arm: Could not open '/lib/arm/2.27/lib/ld-linux.so.3': No such file or directory
```

To solve this problem, we can create a symlink to the current ARM interpreter:
```
sudo ln -s /lib/arm-linux-gnueabi/ld-linux.so.3 /lib/arm/2.27/lib/ld-linux.so.3
```
(Maybe there is a better solution like specify the interpreter in QEMU
parameters, but I didn't find it)


Additionally, in case we want to debug the program with gdb, we can indicate to
QEMU to run a gdbserver:
```
qemu-arm -g 2000 armel-example-dynamic
```

And then connect with gdb-multiarch, that we need to install first:
```
sudo apt install gdb-multiarch
```

And then launch and connect to the QEMU gdbserver:
```
$ gdb-multiarch armel-example-dynamic -q
Reading symbols from armel-example-dynamic...
(No debugging symbols found in armel-example-dynamic)
(gdb) target remote :2000
```

Resources:
- [Debian wiki: QEMU User Emulation](https://wiki.debian.org/QemuUserEmulation)
- [Emulating AARCH64(ARM64) with QEMU â€“ Part 1](https://blog.jitendrapatro.me/emulating-aarch64arm64-with-qemu-part-1/) by Phoenix
- [Running Arm Binaries on x86 with QEMU-User](https://azeria-labs.com/arm-on-x86-qemu-user/) by Azeria

## ARM shellcode

- 2009 [Alphanumeric RISC ARM Shellcode](https://phrack.org/issues/66/12) by Yves Younan and Pieter Philippaerts
- 2017 [Introduction to Writing ARM Shellcode](https://azeria-labs.com/writing-arm-shellcode/) by Azeria

### ARM shellcode: data cache and instruction cache

When executing a shellcode in an armhf challenge ([stack5 from protostar](https://web.archive.org/web/20140405135301/http://exploit-exercises.com/protostar/stack5)
with executable stack and ASLR disabled specifically), after crafting the
shellcode and working perfectly under gdb, in raised the following exception:
```
$ ./stack5 < <(perl -e 'print "\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x49\x40\x52\x40\xc2\x71\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x01" . "b"x40 . "\xb0\xf1\xfe\xff"')
Illegal instruction
```

After some digging, the issue came from the use of data and instructions cache
by ARM.

Some ARM processors have two separated caches for data (D-cache) and
instructions (I-cache). From my experience the D-cache and I-cache are present
in armhf, aka armv7, but not sure other versions.

The problem when executing a shellcode in one of these ARM processors is that we
need to force that, first the shellcode bytes (data) are written to the memory
and not just keep on the data cache, and then the instruction cache is refreshed
with our data (that I think it will happen automatically unless we overwrite
other code, which is weird).

In order to indicate a program to clear the data and instruction cache, the
glibc exports the [cacheflush](https://www.man7.org/linux/man-pages/man2/cacheflush.2.html) function in certain architectures, but in my
experience this is not the case in ARM. The alternative is to use the
[__builtin___clear_cache(void *begin, void *end)](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005f_005f_005fclear_005fcache) function introduced by GCC
in your code, that in case of armhf translates to a call to the function
`__clear_cache` introduced by GCC. `__clear_cache` in turn calls the
[cacheflush](https://www.man7.org/linux/man-pages/man2/cacheflush.2.html) syscall, as we can see in the following snippet:

```
Dump of assembler code for function __clear_cache:
   0x000008ec <+0>:	push	{r7}
   0x000008ee <+2>:	movw	r7, #2
   0x000008f2 <+6>:	movt	r7, #15
   0x000008f6 <+10>:	mov.w	r2, #0
   0x000008fa <+14>:	svc	0
   0x000008fc <+16>:	pop	{r7}
   0x000008fe <+18>:	bx	lr
```

We can see that *r7* stores the value `0xf0002` that corresponds with the
cacheflush syscall number defined for armhf:
```
$ grep -n cache -B 2 /usr/include/arm-linux-gnueabihf/asm/unistd.h
33-#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
34-#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
35:#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
```

In fact, when I added as a test the `__builtin_clear_cache` function to the
stack5 code (as the following snippet indicates), it make my exploit work
perfectly.
```c
#include <stdio.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
  __builtin___clear_cache(buffer, buffer + 72);
}
```

Another alternative seems to use the MCR instruction to indicate the MMU (Memory
Management Unit) to invalidate the data cache: [Understanding MRC on ARM7](https://stackoverflow.com/questions/19544694/understanding-mrc-on-arm7).

Another option seems to call [mprotect](https://www.man7.org/linux/man-pages/man2/mprotect.2.html) before execute the shellcode can
also work but in my experience it only does if it actually changes the memory
permissions. For example, if we write a shellcode in an `rw` area and we make it
`rwx`, then the cache are invalidated, but if we write somehow in a `rwx` area
and then make it `rwx` again (we don't change anything), the cache is not
refreshed. This shouldn't be a problem since most of the times the shellcodes
are written in `rw` areas.

And finally the another option it is to call [sleep](https://www.man7.org/linux/man-pages/man3/sleep.3.html) or a similar one, for my
exploit in the stack5 exercise I called [usleep](https://www.man7.org/linux/man-pages/man3/usleep.3.html) before my shellcode (located
in the executable stack) and it worked.

- 2019 [Why is My Perfectly Good Shellcode Not Working?: Cache Coherency on MIPS and ARM](https://web.archive.org/web/20191212201746/https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm)
- 2013 [Caches and Self-Modifying Code](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/caches-and-self-modifying-code)
- 2014 [Android Hackers Handbook: Chapter 9 - Separate Code and Instruction Cache](https://archive.org/details/AndroidHackersHandbook/page/n323/mode/2up
)
